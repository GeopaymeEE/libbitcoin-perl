
Address.pm,204
package Bitcoin::Address;Bitcoin::Address2,19
sub size() { 160 }size11,172
sub default_version() { Bitcoin::TEST ? 1 : 0 }default_version12,191
sub new {new19,315
sub _from_PEM {_from_PEM34,835

Base58.pm,910
package Bitcoin::Base58;Bitcoin::Base583,58
    sub decode { shift =~ m/.$/p ? $b58{${^MATCH}} + 58*decode(${^PREMATCH}) : 0 }decode20,297
    sub encode { my $_ = shift; return encode($_/58) . (BASE58)[$_%58] if $_ > 0 } encode21,380
package Bitcoin::Base58::Data;Bitcoin::Base58::Data24,467
sub _no_class    { my $_ = shift; die "class method call not implemented" unless ref; return $_ }_no_class42,879
sub _no_instance { my $_ = shift; die "instance method call not implemented" if ref;  return $_ }_no_instance43,977
sub value   { shift->_no_class->[0] }value47,1144
sub data    { pack 'H*', shift->_no_class->value->as_hex =~ s/0x//r }data48,1182
sub version { my $_ = shift; ref() ? $_->[1] // ref->default_version : $_->default_version }version49,1252
    sub new {new55,1382
    sub checksum {checksum76,2179
    sub to_hex {to_hex83,2389
    sub to_base58 {to_base5888,2546

Block.pm,546
package Bitcoin::Block;Bitcoin::Block2,19
sub new {new14,192
	    SEARCH: {SEARCH69,2381
sub _no_instance { my $_ = shift; die "instance method call not implemented" if ref;  return $_ }_no_instance100,3660
sub _no_class    { my $_ = shift; die "class method call not implemented" unless ref; return $_ }_no_class101,3758
sub header {header103,3857
sub unbless {unbless116,4217
sub serialize {serialize127,4373
sub check_proof_of_work {check_proof_of_work135,4563
package Bitcoin::Block::HEADER;Bitcoin::Block::HEADER148,5031

Database.pm,124
package Bitcoin::Database;Bitcoin::Database2,16
use constant NAMES => qw(blkindex);NAMES7,83
sub import {import22,608

DataStream.pm,920
package Bitcoin::DataStream;Bitcoin::DataStream2,16
sub new {new47,710
sub clear { my $_ = shift->_no_class; @$_[0,1] = (0, '') }clear56,863
sub map_file {map_file58,923
sub seek_file { my $_ = shift->_no_class; $_->[0] = shift }seek_file66,1095
sub close_file { undef shift->_no_class->[1] }close_file67,1155
sub Read {Read69,1203
sub Write {Write82,1699
sub read_string {read_string90,1933
sub write_string {write_string97,2102
sub read_bytes {read_bytes104,2246
sub read_compact_size {read_compact_size113,2481
sub write_compact_size {write_compact_size122,2765
sub Length { scalar map 1, shift =~ /./msg }Length132,3143
sub calc_size {calc_size133,3188
sub _no_class    { my $_ = shift; die "class method not implemented"    unless ref; return $_ }_no_class145,3355
sub _no_instance { my $_ = shift; die "instance method not implemented" if ref;     return $_ }_no_instance146,3451

Electrum.pm,192
package Bitcoin::Electrum;Bitcoin::Electrum2,19
use constant COMMANDS => qw(COMMANDS5,59
use constant DEFAULT => {DEFAULT10,209
sub py2json {py2json26,570
sub json2py {json2py31,717

PrivateKey.pm,634
package Bitcoin::PrivateKey;Bitcoin::PrivateKey2,16
use constant G => secp256k1->{G};G17,250
use constant DUMMY_PASSWD => 'dummy password';DUMMY_PASSWD20,319
sub size { 256 }size23,387
sub default_version { Bitcoin::TEST ? 128 : 129 }default_version24,404
sub new {new60,1101
sub value {value69,1466
sub encrypt {encrypt75,1601
sub decrypt {decrypt83,1823
sub public_point { EC::mult shift->_no_class->value, G }public_point92,2081
sub address { new Bitcoin::Address $_[0]->public_point, $_[1] }address93,2138
sub _from_PEM {_from_PEM95,2203
    sub cipher {cipher107,2432
    sub randInt {randInt119,2690

Script.pm,2733
package Bitcoin::Script;Bitcoin::Script2,16
sub check_size { die "stack is too small" if @S < shift }check_size24,1213
sub Pop { pop @S // die "stack is too small" }Pop25,1271
sub Push { push @S, @_ }Push26,1318
sub OP_TOALTSTACK   { push @alt_S, $S[$#S] // die "empty stack" }OP_TOALTSTACK28,1344
sub OP_FROMALTSTACK { Push pop @alt_S // die "empty alt stack" }OP_FROMALTSTACK29,1410
sub OP_DROP  { Pop }OP_DROP30,1475
sub OP_2DROP { Pop, Pop }OP_2DROP31,1496
sub OP_DUP   { check_size 1; Push $S[$#S] }OP_DUP32,1522
sub OP_2DUP  { check_size 2; Push @S[$#S-1,$#S] }OP_2DUP33,1566
sub OP_3DUP  { check_size 3; Push @S[$#S-2 .. $#S] }OP_3DUP34,1616
sub OP_2OVER { check_size 4; splice @S, -4, 0, @S[$#S-1,$#S] }OP_2OVER35,1669
sub OP_2ROT  { check_size 6; Push splice @S, -6, 2 }OP_2ROT36,1732
sub OP_2SWAP { check_size 4; Push splice @S, -4, 2 }OP_2SWAP37,1785
sub OP_IFDUP { check_size 1; Push $S[$#S] if $S[$#S] }OP_IFDUP38,1838
sub OP_DEPTH { Push scalar @S }OP_DEPTH39,1893
sub OP_NIP   { check_size 2; splice @S, -2, 1 }OP_NIP40,1925
sub OP_OVER  { check_size 2; Push $S[$#S-1] }OP_OVER41,1973
sub OP_PICK  { check_size my $n = shift;  Push $S[$#S - $n + 1] }OP_PICK42,2019
sub OP_ROLL  { check_size my $n = shift;  Push $S[$#S - $n + 1]; splice @S, -$n, 1 }OP_ROLL43,2085
sub OP_ROT   { check_size 3; Push splice @S, -3, 1 }OP_ROT44,2170
sub OP_SWAP  { OP_NIP OP_ROT OP_DUP }OP_SWAP45,2223
sub OP_TUCK  { OP_ROT OP_ROT OP_DUP }OP_TUCK46,2261
sub OP_SHA1      { use Digest::SHA qw(sha1);   Push sha1 OP_DROP }OP_SHA148,2300
sub OP_SHA256    { use Digest::SHA qw(sha256); Push sha256 OP_DROP }OP_SHA25649,2367
sub OP_HASH160   { use Bitcoin; Push Bitcoin::hash160 OP_DROP }OP_HASH16050,2436
sub OP_HASH256   { use Bitcoin; Push Bitcoin::hash    OP_DROP }OP_HASH25651,2500
use constant CODE => {CODE66,2997
sub new {new227,14051
sub binary_code { my $_ = shift; die 'empty code' if $_->{code} eq ''; pack 'H*', $_->{code}  }binary_code233,14232
sub first_char  { my $_ = shift; ord substr $_->binary_code, 0, 1 }first_char234,14328
sub data_length {data_length235,14396
sub data_offset {data_offset244,14763
sub decode {decode255,14993
package Bitcoin::Script::OP;Bitcoin::Script::OP276,15739
sub decode {decode278,15800
package Bitcoin::Script::PushData;Bitcoin::Script::PushData288,16088
sub decode {decode290,16155
sub binary_data { my $_ = shift; substr $_->binary_code, $_->data_offset }binary_data303,16568
package Bitcoin::Script::PushData::ASCII;Bitcoin::Script::PushData::ASCII305,16644
sub decode {decode307,16728
package Bitcoin::Script::PushData::PublicKey;Bitcoin::Script::PushData::PublicKey313,16812
sub decode {decode316,16922

template.pm,41
package Bitcoin::NAMEBitcoin::NAME2,16

Transaction.pm,346
package Bitcoin::Transaction;Bitcoin::Transaction2,16
sub new {new13,167
sub serialize {serialize43,1267
sub _no_instance { my $_ = shift; die "instance method call not implemented" if ref;  return $_ }_no_instance62,2361
sub _no_class    { my $_ = shift; die "class method call not implemented" unless ref; return $_ }_no_class63,2459

Wallet.pm,117
package Bitcoin::Wallet;Bitcoin::Wallet2,19
sub FETCH {FETCH13,181
sub STORE {STORE20,364
sub add {add29,799

../Bitcoin.pm,356
package Bitcoin;Bitcoin2,19
use constant BASE58	=> qw{BASE587,98
sub hash160 {hash16032,886
sub hash160_hex { return unpack 'H*', hash160 @_ }hash160_hex39,1052
sub genesis { TEST ? GENESIS_TEST : GENESIS };genesis41,1104
    sub hash     { sha256 sha256 shift }hash47,1210
    sub hash_hex { unpack 'H*', reverse hash shift }hash_hex48,1251

../EC.pm,285
package EC;EC3,49
sub set_param {set_param19,232
    sub Delta { -16*(4*$a**3 + 27*$b**2) }Delta27,364
    sub check {check28,407
    sub Cmp {Cmp36,719
    sub double {double40,849
    sub add {add47,1086
    sub mult {mult58,1516
package EC::Point;EC::Point76,1975

../NumberTheory.pm,147
package NumberTheory;NumberTheory2,16
use constant DC_REGISTERS => 'DC_REGISTERS13,190
sub dc {dc28,435
sub inverse_mod {inverse_mod37,622

../PadWalker.pm,33
package PadWalker;PadWalker1,0
