
DataStream.pm,2171
package Bitcoin::DataStream;Bitcoin::DataStream2,16
sub new {new47,710
sub clear { my $_ = shift->_no_class; @$_[0,1] = (0, '') }clear56,863
sub map_file {map_file58,923
sub seek_file { my $_ = shift->_no_class; $_->[0] = shift }seek_file66,1095
sub close_file { undef shift->_no_class->[1] }close_file67,1155
sub Read {Read69,1203
sub Write {Write79,1491
sub read_string {read_string87,1725
sub write_string {write_string94,1894
sub read_bytes {read_bytes101,2038
sub read_compact_size {read_compact_size110,2273
sub write_compact_size {write_compact_size119,2557
sub Length { scalar map 1, shift =~ /./msg }Length129,2935
sub calc_size {calc_size130,2980
sub _no_class    { my $_ = shift; die "class method not implemented"    unless ref; return $_ }_no_class141,3125
sub _no_instance { my $_ = shift; die "instance method not implemented" if ref;     return $_ }_no_instance142,3221
sub _read_num {_read_num144,3318
sub _write_num {_write_num153,3538
sub read_boolean  { return substr(shift->read_bytes(1), 0, 1) ne chr 0 }read_boolean162,3690
sub read_int16    { return shift->_read_num('s') }read_int16163,3763
sub read_uint16   { return shift->_read_num('S') }read_uint16164,3814
sub read_int32    { return shift->_read_num('l') }read_int32165,3865
sub read_uint32   { return shift->_read_num('L') }read_uint32166,3916
sub read_int64    { return shift->_read_num('q') }read_int64167,3967
sub read_uint64   { return shift->_read_num('Q') }read_uint64168,4018
sub write_boolean { my $_ = shift; return $_->[1] .= chr(shift() ? 1 : 0 ) }write_boolean170,4070
sub write_int16   { my $_ = shift; return $_->_write_num('s', shift) }write_int16171,4147
sub write_uint16  { my $_ = shift; return $_->_write_num('S', shift) }write_uint16172,4218
sub write_int32   { my $_ = shift; return $_->_write_num('l', shift) }write_int32173,4289
sub write_uint32  { my $_ = shift; return $_->_write_num('L', shift) }write_uint32174,4360
sub write_int64   { my $_ = shift; return $_->_write_num('q', shift) }write_int64175,4431
sub write_uint64  { my $_ = shift; return $_->_write_num('Q', shift) }write_uint64176,4502

Script.pm,46
package Bitcoin::Script;Bitcoin::Script2,16

Electrum.pm,192
package Bitcoin::Electrum;Bitcoin::Electrum2,19
use constant COMMANDS => qw(COMMANDS5,59
use constant DEFAULT => {DEFAULT10,209
sub py2json {py2json26,570
sub json2py {json2py31,717

Address.pm,382
package Bitcoin::Address;Bitcoin::Address2,19
sub size { 160 }size26,349
sub default_version { Bitcoin::TEST ? 1 : 0 }default_version27,366
    sub new {new34,500
    sub _value_from_PEM {_value_from_PEM75,1746
    sub checksum {checksum87,2025
    sub toHex {toHex94,2235
    sub toBase58 {toBase58100,2433
sub version {version108,2610
sub value {value113,2709

Block.pm,417
package Bitcoin::Block;Bitcoin::Block2,19
sub new {new14,192
sub _no_instance { my $_ = shift; die "instance method call not implemented" if ref;  return $_ }_no_instance84,2733
sub _no_class    { my $_ = shift; die "class method call not implemented" unless ref; return $_ }_no_class85,2831
sub header {header87,2930
sub serialize {serialize99,3225
sub check_proof_of_work {check_proof_of_work107,3415

Wallet.pm,117
package Bitcoin::Wallet;Bitcoin::Wallet2,19
sub FETCH {FETCH13,181
sub STORE {STORE20,364
sub add {add29,799

template.pm,41
package Bitcoin::NAMEBitcoin::NAME2,16

Network/CAddress.pm,67
package Bitcoin::Network::CAddressBitcoin::Network::CAddress2,16

Electrum/Wallet.pm,480
package Bitcoin::Electrum::Wallet;Bitcoin::Electrum::Wallet2,19
use constant VERSION => 2;VERSION18,359
use constant TEMPLATE => {TEMPLATE19,386
sub passwdToCipher {passwdToCipher30,721
sub new_seed {new_seed35,835
sub wallet_dir {wallet_dir42,1014
sub create_new_address {create_new_address52,1370
sub recover {recover93,2671
sub save {save99,2766
sub is_mine {is_mine105,2912
sub is_change {is_change110,3047
sub get_new_address {get_new_address116,3200

Electrum/Client/GUI/GTK.pm,86
package Bitcoin::Electrum::Client::GUI::GTK;Bitcoin::Electrum::Client::GUI::GTK2,19

Electrum/Client/GUI.pm,76
package Bitcoin::Electrum::Client::GUI;Bitcoin::Electrum::Client::GUI2,19

Electrum/Mnemonic.pm,124
package Bitcoin::Electrum::Mnemonic;Bitcoin::Electrum::Mnemonic2,16
sub encode {encode10,189
sub decode {decode22,451

Electrum/Client.pm,148
package Bitcoin::Electrum::Client;Bitcoin::Electrum::Client9,247
sub raw_tx {raw_tx31,600
sub mktx {mktx81,1858
sub request {request87,1932

PrivateKey.pm,593
package Bitcoin::PrivateKey;Bitcoin::PrivateKey2,16
use constant G => secp256k1->{G};G18,375
use constant DUMMY_PASSWD => 'dummy password';DUMMY_PASSWD21,444
sub size { 256 }size26,532
sub default_version { 128 }default_version27,549
sub toWIF { shift->toBase58 }toWIF30,599
sub new {new60,1195
sub value {value67,1377
sub encrypt {encrypt73,1512
sub decrypt {decrypt82,1779
    sub cipher {cipher95,2128
    sub randInt {randInt107,2387
    sub public_point {public_point112,2539
    sub address {address118,2669
    sub _value_from_PEM {_value_from_PEM125,2842

Database.pm,140
package Bitcoin::Database;Bitcoin::Database2,16
use constant DATA_DIR => $ENV{HOME}.'/.bitcoin';DATA_DIR7,81
sub import {import22,610

Transaction.pm,346
package Bitcoin::Transaction;Bitcoin::Transaction2,16
sub new {new12,146
sub serialize {serialize42,1124
sub _no_instance { my $_ = shift; die "instance method call not implemented" if ref;  return $_ }_no_instance61,2206
sub _no_class    { my $_ = shift; die "class method call not implemented" unless ref; return $_ }_no_class62,2304

Base58.pm,241
package Bitcoin::Base58;Bitcoin::Base583,58
    sub decode { shift =~ m/.$/p ? $b58{${^MATCH}} + 58*decode(${^PREMATCH}) : 0 }decode20,297
    sub encode { my $_ = shift; return encode($_/58) . (BASE58)[$_%58] if $_ > 0 } encode21,380
